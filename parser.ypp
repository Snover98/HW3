%{
/*C++ lang stuff*/
#include <iostream>
#include "SymTable.h"
#include <vector>
#include "Node.h"
#include "output.hpp"
#include <string>

#define YYSTYPE Node*
int yylex();
//void yyerror(const char*);

//functions for enum type conversions
ExpType varToExp(varType t);
VarType expToVar(ExpType e);

//functions for creating new scopes
inline void addEmptyScope();
void addFuncScope(const std::string &ID, const std::vector<FormalStruct> &formals, ExpType ret_type);
//function for removing scope
void popScope();
//function for type -> string conversion
std::string typeToString(varType type);
//function for function -> string conversion
std::string funcToString(FunctionType &func_type);
//get function argument types vector as string
vector<std::string> funcArgTypes(FunctionType &func_type);
//func that adds print and printi to the symbol table
void addPrints();

//the struct types defined in the code
std::vector<<std::vector<StructType> > structs_stack();
structs_stack.push_back(<std::vector<StructType>());
//stack of symbol tables
std::vector<SymTable> tables_stack = std::vector<SymTable>(structs_stack.back());
//number of conditional scopes (if/else/while) we are in, used to validate break statements
unsigned int num_of_while_scopes = 0;
//var for knowing what type the current function returns
ExpType cur_ret_type = VOIDEXP;

addPrints();



%}

%union{
    Node* node;
    Expression* expression;
    Structure* structure;
    Identifier* identifier;
    ExpressionList* expression_list;
    StructMemory* struct_memory;
    StructMemList* struct_memory_list;
    Formal* formal;
    FormalStruct formal_struct;
    FormalsList* formals_list;
}

%left <node> LPAREN
%left <node> RPAREN
%left <node> PERIOD
%left <node> BINOP
%left <node> RELOP
%left <node> AND
%left <node> OR
%nonassoc <node> NOT
%nonassoc <node> TRUE
%nonassoc <node> FALSE
%nonassoc <node> RETURN
%nonassoc <node> IF
%nonassoc <node> ELSE
%nonassoc <node> WHILE
%nonassoc <node> BREAK
%nonassoc <node> CONTINUE
%nonassoc <node> SC
%nonassoc <node> COMMA
%nonassoc <node> LBRACE
%nonassoc <node> RBRACE
%right <node> ASSIGN
%nonassoc <node> VOID
%nonassoc <identifier> ID
%nonassoc <identifier> NUM
%nonassoc <node> STRING
%nonassoc <node> INT
%nonassoc <node> BYTE
%nonassoc <node> B
%nonassoc <node> BOOL
%nonassoc <node> STRUCT

%type <expression> RetType, Call, Type, Exp
%type <formals_list> FormalsList, Formals
%type <formal_struct> FormalDecl
%type <struct_memory_list> StructMemList
%type <struct_memory> StructMem
%type <expression_list> ExpList
%type <structure> StructType



%%

Program:            Structs Funcs {
                                    if(!tables_stack.back().isSymInTable("main")){
                                        output::errorMainMissing();
                                        exit(0);
                                    }
                                    SymEntry e = tables_stack.back().getSymbolEntry("main");
                                    if(e.type != FUNCTYPE || !e.func_type.first.empty() || e.func_type.second != NOTYPE){
                                        output::errorMainMissing();
                                        exit(0)
                                    }
                                    popScope();
                                  };

Funcs:              /*epsilon*/
                    | FuncDecl Funcs
;

FuncDecl:           RetType ID LPAREN Formals RPAREN {addFuncScope($2->ID, $4->formals, $1->exp_type;)} LBRACE Statements RBRACE {
                                                                                                                                     popScope();
                                                                                                                                     cur_ret_type = VOIDEXP;
                                                                                                                                     delete $1;
                                                                                                                                     delete $2;
                                                                                                                                     delete $4;
                                                                                                                                 };

Structs:            /*epsilon*/
                    | StructsDecl Structs
;

StructsDecl:        STRUCT ID LBRACE StructMemList RBRACE SC {
                                                                if(isStructTypeInTable(structs_stack, $2->ID)){
                                                                    output::errorDef(lineno, $2->ID);
                                                                    exit(0);
                                                                }
                                                                if(tables_stack.isSymInTable($2->ID)){
                                                                    output::errorDef(lineno, $2->ID);
                                                                    exit(0);
                                                                }
                                                                structs_stack.back().push_back(StructType($2->ID, $4->fields));
                                                                delete $2;
                                                                delete $4;
                                                             };

RetType:            Type {$$ = $1;}
                    | VOID {$$ = new Expression(VOIDEXP);}
;

Formals:            {$$ = new FormalList();}
                    | FormalsList {$$ = $1;}
;

FormalsList:        FormalDecl {
                                    $$ = new FormalsList();

                                    $$->formals.push_back(*$1);

                                    delete $1;
                               }
                    | FormalDecl COMMA FormalsList {
                                                        $$ = $3;

                                                        if(isParamNameTaken($1->ID)){
                                                            output::errorDef(lineno, $1->ID);
                                                            exit(0);
                                                        }

                                                        $$->formals.push_back(*$1);

                                                        delete $1;
                                                   }
;

FormalDecl:         Type ID {
                                if(tables_stack.back().isSymInTable($1->ID) || isStructTypeInTable(structs_stack, $1->ID)){
                                    output::errorDef(lineno, $1->ID);
                                    exit(0);
                                }
                                $$ = new FormalStruct($2->ID, $1-exp_type);
                                delete $1;
                                delete $2;
                            }
                    | StructType ID {
                                        if(tables_stack.back().isSymInTable($1->ID) || isStructTypeInTable(structs_stack, $1->ID)){
                                            output::errorDef(lineno, $1->ID);
                                            exit(0);
                                        }
                                        $$ = new FormalStruct($2->ID, $1->struct_type);
                                        delete $1;
                                        delete $2;
                                    }
;

StructMemList:      StructMem {
                                $$ = new StructMemList();
                                $$->fields.push_back($1->field);
                                delete $1;
                              }
                    | StructMem StructMemList {
                                                $$ = $2;
                                                if($$->isFieldNameTaken($1->field.first)){
                                                    output::errorDef(lineno, $1->field.first);
                                                    exit(0);
                                                }
                                                $$->fields.push_back($1->field);
                                                delete $1;
                                              }
;

StructMem:          Type ID SC {
                                    $$ = new StructMemory($2->ID, expToVar($2->exp_type));
                                    delete $1;
                                    delete $2;
                               };

Statements:         Statement
                    | Statements Statement
;

Statement:          OpenStatement
                    | ClosedStatement
;

OpenStatement:      IF {addEmptyScope();} LPAREN Exp RPAREN Statement {popScope();}
                    | IF {addEmptyScope();} LPAREN Exp RPAREN ClosedStatement {popScope();} ELSE {addEmptyScope();} OpenStatement {popScope();}
                    | WHILE {addEmptyScope();} LPAREN Exp RPAREN {++num_of_while_scopes;} OpenStatement {--num_of_while_scopes;} {popScope();}
;

ClosedStatement:    SimpleStatement
                    | IF {addEmptyScope();} LPAREN Exp RPAREN ClosedStatement ELSE ClosedStatement
                    | WHILE {addEmptyScope();} LPAREN Exp RPAREN {++num_of_while_scopes;} ClosedStatement {--num_of_while_scopes;} {popScope();}
;

SimpleStatement:    LBRACE {addEmptyScope();} Statements {popScope();} RBRACE
                    | Type ID SC {
                                    if(tables_stack.isSymInTable($2->ID)){
                                        output::errorDef(lineno, $2->ID);
                                        exit(0);
                                    }
                                    tables_stack.back().addEntry($2->ID, expToVar($1->exp_type));
                                    delete $1;
                                    delete $2;
                                 }
                    | StructType ID SC {
                                        if(tables_stack.isSymInTable($2->ID)){
                                            output::errorDef(lineno, $2->ID);
                                            exit(0);
                                        }
                                        tables_stack.back().addEntry($2->ID, $1->struct_type);
                                        delete $1;
                                        delete $2;
                                       }
                    | STRUCT ID LBRACE StructMemList RBRACE SC {
                                                                    if(isStructTypeInTable(structs_stack, $2->ID) || tables_stack.isSymInTable($2->ID)){
                                                                        output::errorDef(lineno, $2->ID);
                                                                        exit(0);
                                                                    }
                                                                    structs_stack.back().push_back(StructType($2->ID, $4->fields));
                                                                    delete $2;
                                                                    delete $4;
                                                               }
                    | Type ID ASSIGN Exp SC {
                                                if(tables_stack.isSymInTable($2->ID)){
                                                    output::errorDef(lineno, $2->ID);
                                                    exit(0);
                                                }
                                                if(!isLegalExpType($1, $4)){
                                                    output::errorMismatch(lineno);
                                                    exit(0);
                                                }
                                                tables_stack.back().addEntry($2->ID, expToVar($1->exp_type));
                                                delete $1;
                                                delete $2;
                                                delete $4;
                                            }
                    | StructType ID ASSIGN Exp SC {
                                                    if(tables_stack.isSymInTable($2->ID)){
                                                        output::errorDef(lineno, $2->ID);
                                                        exit(0);
                                                    }
                                                    if(!isLegalExpType($1, $4)){
                                                        output::errorMismatch(lineno);
                                                        exit(0);
                                                    }
                                                    tables_stack.back().addEntry($2->ID, $1->struct_type);
                                                    delete $1;
                                                    delete $2;
                                                    delete $4;
                                                  }
                    | ID ASSIGN Exp SC {
                                            SymEntry e = getSymbolEntry($1->ID);
                                            if(!tables_stack.isSymInTable($1->ID) || !e.isVariable()){
                                                output::errorUndef(lineno);
                                                exit(0);
                                            }
                                            if(e.type == STRUCTTYPE){
                                                if(!isLegalExpType($3, e.struct_type)){
                                                    output::errorMismatch(lineno);
                                                    exit(0);
                                                }
                                            } else {
                                                if(!isLegalExpType($3, varToExp(e.type))){
                                                    output::errorMismatch(lineno);
                                                    exit(0);
                                                }
                                            }
                                            delete $1;
                                            delete $3;
                                       }
                    | ID PERIOD ID ASSIGN Exp SC {
                                                    SymEntry e = getSymbolEntry($1->ID);
                                                    if(!tables_stack.isSymInTable($1->ID) || !e.isVariable()){
                                                        output::errorUndef(lineno);
                                                        exit(0);
                                                    }
                                                    if(e.type != STRUCTTYPE){
                                                        output::errorMismatch(lineno);
                                                        exit(0);
                                                    }
                                                    if(!isStructTypeInTable(structs_stack, e.struct_type)){
                                                        output::errorUndefStruct(lineno, e.struct_type);
                                                        exit(0);
                                                    }
                                                    StructType t = getStructTypeEntry(structs_stack, e.struct_type);
                                                    varType field_type = t.getFieldType($3->ID);
                                                    if(field_type == NOTYPE){
                                                        output::errorUndefStructMember(lineno, $3->ID);
                                                        exit(0);
                                                    }
                                                    if(!isLegalExpType($5, varToExp(field_type))){
                                                        output::errorMismatch(lineno);
                                                        exit(0);
                                                    }
                                                    delete $1;
                                                    delete $3;
                                                    delete $5;
                                                 }
                    | Call SC
                    | RETURN SC {
                                    if(cur_ret_type != VOIDEXP){
                                        output::errorMismatch(lineno);
                                        exit(0);
                                    }
                                }
                    | RETURN Exp SC {
                                        if(!isLegalExpType($2, cur_ret_type)){
                                            output::errorMismatch(lineno);
                                            exit(0);
                                        }
                                        delete $2;
                                    }
                    | BREAK SC {
                                if(num_of_while_scopes == 0){
                                    output::errorUnexpectedBreak(lineno);
                                    exit(0);
                                }
                               }
                    | CONTINUE SC {
                                    if(num_of_while_scopes == 0){
                                        output::errorUnexpectedContinue(lineno);
                                        exit(0);
                                    }
                                  }
;

Call:               ID LPAREN ExpList RPAREN {
                                                    SymEntry func_e = getSymbolEntry($1->ID);
                                                    if(!tables_stack.isSymInTable($1->ID) || e.type != FUNCTYPE){
                                                        output::errorUndefFunc(lineno, $1->ID);
                                                        exit(0);
                                                    }
                                                    if($3->expressions.size() != func_e.func_type.first.size()){
                                                        output::errorPrototypeMismatch(lineno, $1->ID, funcArgTypes(e.func_type));
                                                        exit(0);
                                                    }

                                                    std::vector<Structure>::iterator it_exp = = $3->expressions.begin();
                                                    std::vector<FuncParam>::iterator it_arg = = func_e.func_type.first.begin();
                                                    for(; it_exp != $3->expressions.end() && it_arg != func_e.func_type.first.end(); ++it_exp && ++it_arg ){
                                                        if((*it_exp).exp_type != varToExp((*it_arg)) || (*it_arg).type == STRUCTTYPE && (*it_arg).struct_type != (*it_exp).struct_type){
                                                            output::errorPrototypeMismatch(lineno, $1->ID, funcArgTypes(e.func_type));
                                                            exit(0);
                                                        }
                                                    }

                                                    $$ = new Expression(varToExp(func_e.func_type.second));
                                                    delete $1;
                                                    delete $3;
                                             }
                    | ID LPAREN RPAREN {
                                            SymEntry func_e = getSymbolEntry($1->ID);
                                            if(!tables_stack.isSymInTable($1->ID) || e.type != FUNCTYPE){
                                                output::errorUndefFunc(lineno, $1->ID);
                                                exit(0);
                                            }
                                            if(!func_e.func_type.first.empty()){
                                                output::errorPrototypeMismatch(lineno, $1->ID, funcArgTypes(e.func_type))
                                                exit(0);
                                            }

                                            $$ = new Expression(varToExp(func_e.func_type.second));
                                            delete $1;
                                       }
;

ExpList:            Exp {
                            $$ = new ExpressionList();
                            $$->expressions.push_back(expressionToList($1));
                            delete $1;
                        }
                    | Exp COMMA ExpList {
                                            $$ = $3;
                                            $$->expressions.push_back(expressionToList($1));
                                            delete $1;
                                        }
;

Type:               INT {$$ = new Expression(INTEXP);}
                    | BYTE {$$ = new Expression(BYTEEXP);}
                    | BOOL {$$ = new Expression(BOOLEXP);}
;

StructType:         STRUCT ID {
                        if(!isStructTypeInTable(structs_stack, $2->ID)){
                            output::errorUndefStruct(lineno, e.struct_type);
                            exit(0);
                        }
                        $$ = new Structure($2->ID);
                        delete $2;
                    };

Exp:                LPAREN Exp RPAREN {$$ = $2;}
                    | Exp BINOP Exp {
                                        if(!isNumExp($1) || !isNumExp($3)){
                                            output::errorMismatch(lineno);
                                            exit(0);
                                        }
                                        $$ = new Expression(operatorType($1, $3));
                                        delete $1;
                                        delete $3;
                                    }
                    | ID {
                            SymEntry e = getSymbolEntry($1->ID);
                            if(!tables_stack.isSymInTable($1->ID) || !e.isVariable()){
                                output::errorUndef(lineno);
                                exit(0);
                            }
                            if(e.type == STRUCTEXP){
                                $$ = new Structure(e.struct_type);
                            } else {
                                $$ = new Expression(varToExp(e.type));
                            }
                            delete $1;
                         }
                    | ID PERIOD ID {
                                        SymEntry e = getSymbolEntry($1->ID);
                                        if(!tables_stack.isSymInTable($1->ID) || !e.isVariable()){
                                            output::errorUndef(lineno);
                                            exit(0);
                                        }
                                        if(e.type != STRUCTTYPE){
                                            output::errorMismatch(lineno);
                                            exit(0);
                                        }
                                        if(!isStructTypeInTable(structs_stack, e.struct_type)){
                                            output::errorUndefStruct(lineno, e.struct_type);
                                            exit(0);
                                        }
                                        StructType t = getStructTypeEntry(structs_stack, e.struct_type);
                                        varType field_type = t.getFieldType($3->ID);
                                        if(field_type == NOTYPE){
                                            output::errorUndefStructMember(lineno, $3->ID);
                                            exit(0);
                                        }
                                        $$ = new Expression(varToExp(field_type));
                                        delete $1;
                                        delete $3;
                                   }
                    | Call {$$ = $1;}
                    | NUM {
                            $$ = new Expression(INTEXP);
                            delete $1;
                          }
                    | NUM B {
                                if(std::stoi($1->ID) > 255){
                                    errorByteTooLarge(lineno, $1->ID)
                                    exit(0);
                                }
                                $$ = new Expression(BYTEEXP);
                                delete $1;
                            }
                    | STRING {$$ = new Expression(STRINGEXP);}
                    | TRUE {$$ = new Expression(BOOLEXP);}
                    | FALSE {$$ = new Expression(BOOLEXP);}
                    | NOT Exp {
                                if($1->exp_type != BOOLEXP){
                                    output::errorMismatch(lineno);
                                    exit(0);
                                }
                                $$ = new Expression(BOOLEXP);
                                delete $2;
                              }
                    | Exp AND Exp {
                                    if($1->exp_type != BOOLEXP || $3->exp_type != BOOLEXP){
                                        output::errorMismatch(lineno);
                                        exit(0);
                                    }
                                    $$ = new Expression(BOOLEXP);
                                    delete $1;
                                    delete $3;
                                  }
                    | Exp OR Exp {
                                    if($1->exp_type != BOOLEXP || $3->exp_type != BOOLEXP){
                                        output::errorMismatch(lineno);
                                        exit(0);
                                    }
                                    $$ = new Expression(BOOLEXP);
                                    delete $1;
                                    delete $3;
                                 }
                    | Exp RELOP Exp {
                                        if(!isNumExp($1) || !isNumExp($3)){
                                            output::errorMismatch(lineno);
                                            exit(0);
                                        }
                                        $$ = new Expression(BOOLEXP);
                                        delete $1;
                                        delete $3;
                                    }
;



%%

ExpType varToExp(varType t){
    switch(t){
        case INTTYPE:
            return INTEXP;
        case BYTETYPE:
            return BYTEEXP;
        case BOOLTYPE:
            return BOOLEXP;
        case STRUCTTYPE:
            return STRUCTEXP;
        case FUNCTYPE:
            return FUNCEXP;
        case STRINGTYPE:
            return STRINGEXP;
        default:
            //note that no entry in the symbol table can be string or void!
            return VOIDEXP;
    }
}

VarType expToVar(ExpType e){
    switch(e){
        case INTEXP:
            return INTTYPE;
        case BYTEEXP:
            return BYTETYPE;
        case BOOLEXP:
            return BOOLTYPE;
        case STRUCTEXP:
            return STRUCTTYPE;
        case FUNCEXP:
            return FUNCTYPE;
        case STRINGEXP:
            return STRINGTYPE;
        default:
            //note that no entry in the symbol table can be string or void!
            return NOTYPE;
    }
}


inline void addEmptyScope(){
    tables_stack.push_back(SymTable(structs_stack, tables_stack.back().nextOffset(), &(tables_stack.back())));
}

void addFuncScope(const std::string &ID, const std::vector<FormalStruct> &formals, ExpType ret_type){
    if(tables_stack.back().isSymInTable(ID) || isStructTypeInTable(structs_stack, ID)){
        output::errorDef(lineno, ID);
    }

    cur_ret_type = ret_type;

    std::vector<FuncParam> func_params = std::vector<FuncParam>();

    for(std::vector<FormalStruct>::const_iterator it = formals.begin(); it!=formals.end(); ++it){
        if((*it).type == STRUCTEXP){
            func_params.push_back(FuncParam((*it).struct_type));
        } else {
            func_params.push_back(FuncParam(ExpToVar((*it).type)));
        }
    }

    tables_stack.back().addEntry(ID, func_params, ret_type);

    addEmptyScope();

    int offset = 0;
    for(std::vector<FormalStruct>::const_iterator it = formals.begin(); it!=formals.end(); ++it){
        SymEntry e;

        if((*it).type == STRUCTEXP){
            offset -= tables_stack.back().structTypeOffset((*it).struct_type);
            e = SymEntry((*it).ID, (*it).struct_type, offset);
        } else {
            e = SymEntry((*it).ID, ExpToVar((*it).type), --offset);
        }

        tables_stack.back().addEntry(e);
    }
}

std::string typeToString(varType type){
    switch(type){
        case INTTYPE:
            return "INT";
        case BYTETYPE:
            return "BYTE";
        case BOOLTYPE:
            return "BOOL";
        case STRUCTTYPE:
            return "struct";
        case STRINGTYPE:
            return "STRING";
        default:
            return "";
    }
}

vector<std::string> funcArgTypes(FunctionType &func_type){
    vector<std::string> argTypes = vector<std::string>();

    for(std::vector<FuncParam>::iterator it = func_type.first.begin(); it != func_type.first.end(); ++it){
        argTypes.push_back(typeToString((*it).type)+(*it).struct_type);
    }

    return argTypes;
}

std::string funcToString(FunctionType &func_type){
    return output::makeFunctionType(typeToString(func_type.second), funcArgTypes(func_type));
}



void popScope(){
    std::vector<SymEntry> scope_entries = tables_stack.back().scope_entries;

    for(std::vector<SymEntry>::iterator it = scope_entries.begin(); it != scope_entries.end(); ++it){
        std::string type;

        if((*it).type == FUNCTYPE){
            type = funcToString((*it).func_type);
        } else{
            type = typeToString((*it).type) + (*it).struct_type;
        }

        output::printID((*it).ID, (*it).offset, type);
    }

    std::vector<StructType> scope_structs = structs_stack.back();

    for(std::vector<StructType>::iterator it = scope_structs.begin(); it != scope_structs.end(); ++it){
        vector<std::string> memTypes = vector<std::string>();
        vector<std::string> memNames = vector<std::string>();

        for(StructFieldsType::const_iterator field_it = (*it).fields.begin(); field_it != (*it).fields.end(); ++field_it){
            memTypes.push_back(typeToString((*field_it).second));
            memNames.push_back((*field_it).first);
        }

        output::printStructType((*it).type_name, memTypes, memNames);
    }

    tables_stack.pop_back();
    structs_stack.pop_back();
}

void addPrints(){
    std::vector<FuncParam> print_func_params = std::vector<FuncParam>();
    std::vector<FuncParam> printi_func_params = std::vector<FuncParam>();

    print_func_params.push_back(FuncParam(STRINGTYPE));
    printi_func_params.push_back(FuncParam(INTTYPE));

    tables_stack.back().addEntry("print", print_func_params, NOTYPE);
    tables_stack.back().addEntry("printi", printi_func_params, NOTYPE);
}



