%{
/*C++ lang stuff*/
#include <iostream>
#include "SymTable.h"
#include <vector>
#include "Node.h"

#define YYSTYPE Node*
int yylex();
void yyerror(const char*);

//function for enum type conversion
ExpType varToExp(varType t);


//the struct types defined in the code
std::vector<StructType> structs();
//stack of symbol tables
std::vector<SymTable> tables_stack = std::vector<SymTable>(structs);
//number of conditional scopes (if/else/while) we are in, used to validate break statements
unsigned int num_of_while_scopes = 0;
//var fo knowing what type the current function returns
ExpType cur_ret_type = VOIDEXP;




%}

%left LPAREN
%left RPAREN
%left PERIOD
%left BINOP
%left RELOP
%left AND
%left OR
%nonassoc NOT
%nonassoc TRUE
%nonassoc FALSE
%nonassoc RETURN
%nonassoc IF
%nonassoc ELSE
%nonassoc WHILE
%nonassoc BREAK
%nonassoc CONTINUE
%nonassoc SC
%nonassoc COMMA
%nonassoc LBRACE
%nonassoc RBRACE
%right ASSIGN
%nonassoc VOID
%nonassoc ID
%nonassoc NUM
%nonassoc STRING
%nonassoc INT
%nonassoc BYTE
%nonassoc B
%nonassoc BOOL
%nonassoc STRUCT




%%

Program:            Structs Funcs;

Funcs:              /*epsilon*/
                    | FuncDecl Funcs
;

FuncDecl:           RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE;

Structs:            /*epsilon*/
                    | StructsDecl Structs
;

StructsDecl:        STRUCT ID LBRACE StructMemList RBRACE SC {

//TODO: something like this: addStructType(structs, StructType(((Identifier&)$2)->ID, (some cast&) $4->fields));

};

RetType:            Type
                    | VOID
;

Formals:            /*epsilon*/
                    FormalsList
;

FormalsList:        FormalDecl
                    | FormalDecl COMMA FormalsList
;

FormalDecl:         Type ID
                    | StructType ID
;

StructMemList:      StructMem
                    | StructMem StructMemList
;

StructMem:          Type ID SC;

Statements:         Statement
                    | Statements Statement
;

Statement:          OpenStatement
                    | ClosedStatement
;

OpenStatement:      IF LPAREN Exp RPAREN Statement
                    | IF LPAREN Exp RPAREN ClosedStatement ELSE OpenStatement
                    | WHILE LPAREN Exp RPAREN {++num_of_while_scopes;} OpenStatement {--num_of_while_scopes;}
;

ClosedStatement:    SimpleStatement
                    | IF LPAREN Exp RPAREN ClosedStatement ELSE ClosedStatement
                    | WHILE LPAREN Exp RPAREN {++num_of_while_scopes;} ClosedStatement {--num_of_while_scopes;}
;

SimpleStatement:    LBRACE Statements RBRACE
                    | Type ID SC
                    | StructType ID SC
                    | STRUCT ID LBRACE StructMemList RBRACE SC
                    | Type ID ASSIGN Exp SC
                    | StructType ID ASSIGN Exp SC
                    | ID ASSIGN Exp SC
                    | ID PERIOD ID ASSIGN Exp SC
                    | Call SC
                    | RETURN SC {if(cur_ret_type != VOIDEXP) errorMismatch(lineno);}
                    | RETURN Exp SC {if(!isLegalExpType($2, cur_ret_type)) errorMismatch(lineno);}
                    | BREAK SC {if(num_of_while_scopes == 0) errorUnexpectedBreak(lineno);}
                    | CONTINUE SC {if(num_of_while_scopes == 0) errorUnexpectedContinue(lineno);}
;

Call:               ID LPAREN ExpList RPAREN {
                                                    SymEntry func_e = getSymbolEntry($1->ID);
                                                    if(!isSymInTable($1->ID) || !e.isVariable()) errorUndefFunc(lineno, $1->ID);
                                                    if(e.type != FUNCTYPE) errorUndefFunc(lineno, $1->ID);
                                                    //@TODO use errorPrototypeMismatch correctly
                                                    if($3->expressions.size() != func_e.func_type.first.size()) errorPrototypeMismatch();

                                                    std::vector<Expression>::iterator it_exp = = $3->expressions.begin();
                                                    std::vector<varType>::iterator it_arg = = func_e.func_type.first.begin();
                                                    for(; it_exp != $3->expressions.end() && it_arg != func_e.func_type.first.end(); ++it_exp && ++it_arg ){
                                                        //@TODO use errorPrototypeMismatch correctly
                                                        if((*it_exp).exp_type != varToExp((*it_arg))) errorPrototypeMismatch();
                                                        //@TODO make it possible to compare the specific struct types
                                                        if(*it_arg == STRUCTTYPE && !STRUCT_TYPES_EQUAL) errorPrototypeMismatch();
                                                    }

                                                    $$ = new Expression(varToExp(func_e.func_type.second));
                                                    delete $1;
                                                    delete $3;
                                             }
                    | ID LPAREN RPAREN {
                                            SymEntry func_e = getSymbolEntry($1->ID);
                                            if(!isSymInTable($1->ID) || !e.isVariable()) errorUndefFunc(lineno, $1->ID);
                                            if(e.type != FUNCTYPE) errorUndefFunc(lineno, $1->ID);
                                            //@TODO use errorPrototypeMismatch correctly
                                            if(!func_e.func_type.first.empty()) errorPrototypeMismatch();

                                            $$ = new Expression(varToExp(func_e.func_type.second));
                                            delete $1;
                                       }
;

ExpList:            Exp {
                            $$ = new ExpressionList();
                            $$->expressions.push_back(*($1));
                            delete $1;
                        }
                    | Exp COMMA ExpList {
                                            $$ = $3;
                                            $$->expressions.push_back(*($1));
                                            delete $1;
                                        }
;

Type:               INT {$$ = new Expression(INTEXP);}
                    | BYTE {$$ = new Expression(BYTEEXP);}
                    | BOOL {$$ = new Expression(BOOLEXP);}
;

StructType:         STRUCT ID {
                        if(!isStructTypeInTable(structs, $2->ID)) errorUndefStruct(lineno, e.struct_type);
                        $$ = new Structure($2->ID);
                        delete $2;
                    };

Exp:                LPAREN Exp RPAREN {$$ = $2;}
                    | Exp BINOP Exp {
                                        if(!isNumExp($1) || !isNumExp($3)) errorMismatch(lineno);
                                        $$ = new Expression(operatorType($1, $3));
                                        delete $1;
                                        delete $3;
                                    }
                    | ID {
                            SymEntry e = getSymbolEntry($1->ID);
                            if(!isSymInTable($1->ID) || !e.isVariable()) errorUndef(lineno);
                            if(e.type == STRUCTEXP){
                                $$ = new Structure(e.struct_type);
                            } else {
                                $$ = new Expression(varToExp(e.type));
                            }
                            delete $1;
                         }
                    | ID PERIOD ID {
                                        SymEntry e = getSymbolEntry($1->ID);
                                        if(!isSymInTable($1->ID) || !e.isVariable()) errorUndef(lineno);
                                        if(e.type != STRUCTTYPE) errorMismatch(lineno);
                                        if(!isStructTypeInTable(structs, e.struct_type)) errorUndefStruct(lineno, e.struct_type);
                                        StructType t = getStructTypeEntry(structs, e.struct_type);
                                        varType field_type = t.getFieldType($3->ID);
                                        if(field_type == NOTYPE) errorUndefStructMember(lineno, $3->ID);
                                        $$ = new Expression(varToExp(field_type));
                                        delete $1;
                                        delete $3;
                                   }
                    | Call {$$ = $1;}
                    | NUM {$$ = new Expression(INTEXP);}
                    | NUM B {
                                //@TODO make sure that the byte value is <= 255
                                $$ = new Expression(BYTEEXP);
                            }
                    | STRING {$$ = new Expression(STRINGEXP);}
                    | TRUE {$$ = new Expression(BOOLEXP);}
                    | FALSE {$$ = new Expression(BOOLEXP);}
                    | NOT Exp {
                                if($1->exp_type != BOOLEXP) errorMismatch(lineno);
                                $$ = new Expression(BOOLEXP);
                                delete $2;
                              }
                    | Exp AND Exp {
                                    if($1->exp_type != BOOLEXP || $3->exp_type != BOOLEXP) errorMismatch(lineno);
                                    $$ = new Expression(BOOLEXP);
                                    delete $1;
                                    delete $3;
                                  }
                    | Exp OR Exp {
                                    if($1->exp_type != BOOLEXP || $3->exp_type != BOOLEXP) errorMismatch(lineno);
                                    $$ = new Expression(BOOLEXP);
                                    delete $1;
                                    delete $3;
                                 }
                    | Exp RELOP Exp {
                                        if(!isNumExp($1) || !isNumExp($3)) errorMismatch(lineno);
                                        $$ = new Expression(BOOLEXP);
                                        delete $1;
                                        delete $3;
                                    }
;



%%

ExpType varToExp(varType t){
    switch(t){
        case INTTYPE:
            return INTEXP;
        case BYTETYPE:
            return BYTEEXP;
        case BOOLTYPE:
            return BOOLEXP;
        case STRUCTTYPE:
            return STRUCTEXP;
        case FUNCTYPE:
            return FUNCEXP;
        default:
            //note that no entry in the symbol table can be string or void!
            return VOIDEXP;
    }
}













